// Lic:
// Quick Version
// Can quickly set up a version header file
// 
// 
// 
// (c) Jeroen P. Broks, 2022
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
// 
// Please note that some references to data like pictures or audio, do not automatically
// fall under this licenses. Mostly this is noted in the respective files.
// 
// Version: 22.12.16
// EndLic
#define IncQVersion
#include <SlyvGINIE.hpp>
#include <SlyvStream.hpp>
#include <SlyvString.hpp>
#include <SlyvQCol.hpp>
#include <SlyvTime.hpp>
#include <SlyvSTOI.hpp>
#include <SlyvConInput.hpp>


#ifdef IncQVersion
#include "QVersion_Version.hpp"
#endif

using namespace std;
using namespace Slyvina::Units;

enum class update { nihil, minor, major, giant };
enum class status { wip, alpha, beta, stable };
enum errors { noerror, unknownswitch, nonexistentproject, noprojects, unknownupdatetype, unknownstatustype, unknownprogramminglanguage };

struct TPRJ { std::string prj; update upd; status sts{status::wip}; UGINIE data; };
std::vector<TPRJ> Projects{};

int GoForIt(TPRJ* Prj) {
	QCol->Doing("Processing", Prj->prj);
	int gi{ std::max(0,ToInt(Prj->data->Value("Version","Giant"))) }, ma{ std::max(0, ToInt(Prj->data->Value("Version", "Major"))) }, mi{ std::max(0,ToInt(Prj->data->Value("Version","minor"))) };
	auto dt{ QTimeF("%Y%m%d%H%M%S") };
	auto out{ "" };
	switch (Prj->upd) {
	case update::nihil: break; // do nothing
	case update::minor: mi++; Prj->data->Value("Version", "Minor", to_string(mi)); break;
	case update::major: mi=0; Prj->data->Value("Version", "Minor", "0"); ma++; Prj->data->Value("Version", "Major", to_string(ma)); break; 
	case update::giant: mi = 0; Prj->data->Value("Version", "Minor", "0"); ma = 0; Prj->data->Value("Version", "Major", "0"); gi++; Prj->data->Value("Version", "Giant", to_string(gi)); break;
	default: QCol->Error(TrSPrintF("Unknown update kind (%d) - This can only be the result of a bug. Please report this exact error and what you did!")); return unknownupdatetype;
	}
	switch (Prj->sts) {
	case status::wip: Prj->data->Value("Version", "Status", "WIP/In development"); break;
	case status::alpha: Prj->data->Value("Version", "Status", "Alpha"); break;
	case status::beta: Prj->data->Value("Version", "Status", "Beta"); break;
	case status::stable: Prj->data->Value("Version", "Status", "Stable"); break;
	default: QCol->Error(TrSPrintF("Unknown status kind (%d) - This can only be the result of a bug. Please report this exact error and what you did!")); return unknownstatustype;
	}
	auto Lang{ Upper(Prj->data->Value("Project", "Language")) };
	if (Lang == "") { Lang = "C++"; Prj->data->Value("Project", "Language", "C++"); }
	if (Lang == "C") {
		std::string nsp{ "" };
		auto spaces{ Prj->data->List("Project", "NameSpaces") };
		for (auto& ns : *spaces) {
			//QCol->Doing("Namespace", ns); // debug only!!!
			nsp += ns + "_";
		}
		//char* nspc = new char(nsp.size() + 3);
		//strcpy_s(nspc, nsp.size()+1, nsp.c_str());
		SaveString(
			Prj->data->Value("Project", "Output"),
			TrSPrintF(
				"#define %sProject \"%s\"\n"
				"#define %sGiant %d\n"
				"#define %sMajor %d\n"
				"#define %sMinor %d\n"
				"#define %sDTCode \"%s\"\n"
				"#define %sStatus \"%s\"\n\n"
				"#define %sVersion \"%d.%d.%d.%s\""
				,
				nsp.c_str(), Prj->data->Value("Project", "Name").c_str(),
				nsp.c_str(), gi,
				nsp.c_str(), ma,
				nsp.c_str(), mi,
				nsp.c_str(), dt.c_str(),
				nsp.c_str(), Prj->data->Value("Version", "Status").c_str(),
				nsp.c_str(), gi, ma, mi, dt.c_str()
			)
		);
		// delete[] nspc;
	} else if (Lang=="C++") {
		std::string tabs{ "" };
		std::string src{ "#pragma once\n#include <string>\n\n// This code is generated by QVersion! It's best NOT to manutally alter it!\n\n" };
		auto spaces{ Prj->data->List("Project", "NameSpaces") };
		for (auto& ns : *spaces) {
			src += tabs + "namespace " + ns + " {\n";
			tabs += "\t";
		}
		src += tabs + "class QVersionClass {\n";
		src += tabs + "public:\n";
		src += tabs + "\tunsigned int giant{0}, major{0}, minor{0}; \n";
		src += tabs + "\tstd::string dt{\"00000000000000\"};\n";
		src += tabs + "\tstd::string Status{\"Stable\"};\n";
		src += tabs + "\tinline std::string Version(bool full=true) {\n";
		src += tabs + "\t\tstd::string ret{ std::to_string(giant)+\".\"+std::to_string(major)+\".\"+std::to_string(minor) };\n";
		src += tabs + "\t\tif (full) ret+=\".\"+dt;\n";
		src += tabs + "\t\tif (Status!=\"Stable\") ret += \" (\" + Status + \")\";\n";
		src += tabs + "\t\treturn ret;\n";
		src += tabs + "\t}\n";
		src += tabs + "\tinline QVersionClass(){} // Fuck you!\n";
		src += tabs + "\tinline QVersionClass(unsigned int _giant,unsigned int _major,unsigned int _minor,std::string _dt=\"00000000000000\",std::string _status=\"Stable\") {\n";
		src += tabs + "\t\tgiant=_giant; major=_major; minor=_minor; dt=_dt; Status=_status;\n";
		src += tabs + "\t}\n";
		if (Upper(Prj->data->Value("C++", "AddWant")) == "YES") {
			src += tabs + "\tinline bool WantVersion(unsigned int _giant,unsigned int _major=0,unsigned int _minor=0) {\n";
			src += tabs + "\t\tif (giant< _giant) return false;\n";
			src += tabs + "\t\tif (giant==_giant && major< _major) return false;\n";
			src += tabs + "\t\tif (giant==_giant && major==_major && minor<_minor) return false;\n";
			src += tabs + "\t\treturn true;\n";
			src += tabs + "\t}\n";
		}

		src += tabs + "};\n\n";

		if (Prj->data->Value("Version", "Status") == "") Prj->data->Value("Version", "Status", "WIP/In development");
		src += tabs + TrSPrintF("static QVersionClass QVersion{%d,%d,%d,\"%s\",\"%s\"};\n\n", gi, ma, mi, dt.c_str(), Prj->data->Value("Version", "Status").c_str());

		for (size_t i = spaces->size(); i > 0; i--) {
			for (Slyvina::byte j = 1; j < i; j++) src += "\t";
			src += "} // namespace " + (*spaces)[i - 1] + "\n";
		}
		SaveString(Prj->data->Value("Project", "Output"), src);
	} else {
		QCol->Error("Unknown programming language: " + Lang);
		return unknownprogramminglanguage;
	}
	return noerror;
}

int main(int countargs, char** args) {
	QCol->Magenta("Quick Version - ");
	#ifdef IncQVersion
	QCol->Doing("Version", Slyvina::Version::QuickVersion::QVersion.Version(true));
#else
	QCol->Red("Unversioned!\n");
#endif
	// Add version here
	QCol->Doing("Coded by", "Jeroen P. Broks");
	QCol->Dark("(c) Copyright Jeroen P. Broks - Licensed under the terms of the GPL3\n\n");
	string prj{ "" };
	update upd{ update::nihil };
	status sts{ status::wip };
	for (auto i = 1; i < countargs; i++) {
		if (args[i][0] == '-') {
			if (strcmp(args[i], "-minor") == 0)
				upd = update::minor;
			else if (strcmp(args[i], "-major") == 0)
				upd = update::major;
			else if (strcmp(args[i], "-giant") == 0)
				upd = update::giant;
			else if (strcmp(args[i], "-nihil") == 0)
				upd = update::nihil;
			else if (strcmp(args[i], "-wip") == 0)
				sts = status::wip;
			else if (strcmp(args[i], "-alpha") == 0)
				sts = status::alpha;
			else if (strcmp(args[i], "-beta") == 0)
				sts = status::beta;
			else if (strcmp(args[i], "-stable") == 0 || strcmp(args[i], "-release"))
				sts = status::stable;
			else {
				QCol->Error(TrSPrintF("Unknown switch '%s'!", args[i]));
				return unknownswitch;
			}
		} else {
			prj = args[i];
			if (!FileExists(prj)) {
				QCol->Red("\x7The project file " + prj + " does not appear to exist!\n");
				QCol->Yellow("Create it? ");
				QCol->LCyan("<Y/N> ");
				auto Answer{ Trim(Upper(ReadLine())) };
				if (Answer.size() && Answer[0] == 'Y') {
					QCol->Doing("Name project", "", ""); auto Name{ ReadLine() }; if (!Name.size()) Name = StripAll(prj);
					QCol->Doing("PrgLanguage", "", ""); auto PrgLanguage{ ReadLine() }; if (!PrgLanguage.size()) PrgLanguage = "C++";
					QCol->Doing("QV Output", "", ""); auto Output{ ReadLine() }; if (!Output.size()) Output = ExtractDir(prj) + "/QVersion.h";
					auto src = "# Creation!\n\n[Project]\nCreated=" + CurrentDate() + "; " + CurrentTime() + "\nName=" + Name + "\nLanguage=" + PrgLanguage + "\nOutput="+Output+"\n*list:NameSpaces\n";
					std::string nsAnswer;
					QCol->Doing("NameSpaces", "");
					do {
						nsAnswer = Trim(ReadLine(">"));
						if (!nsAnswer.size()) break;
						src += nsAnswer + "\n";

					} while (true);
					src += "*end\n";
					SaveString(prj, src);
				} else {
					return nonexistentproject;
				}
			}
			Projects.push_back(TPRJ{ prj,upd,sts,LoadUGINIE(prj,prj,"QuickVersion Project") });
		}
	}
	//QCol->Doing("Projects", to_string(Projects.size())); // debug
	//QCol->Doing("Version check test",Slyvina::Version::QuickVersion::QVersion.WantVersion(0, 0, 25));
	if (Projects.size()) {
		int i = 0;
		for (auto& P : Projects) {
			i |= GoForIt(&P);
		}
		return i;
	} else {
		QCol->Dark("Usage: ");
		QCol->Yellow(StripAll(args[0]));
		QCol->Green(" [<switches>]");
		QCol->Cyan(" <Project> [<Project2>[<Project3>....]]\n\n");
		QCol->Yellow("Status Switches: -wip -alpha -beta -stable\n");
		QCol->Yellow("Update Switches: -nihil -minor -major -release\n");
		QCol->Reset();
		return noprojects;
	}
}